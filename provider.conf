include required(classpath("application"))

backend {
  default = "ContainerisedLSF"

  providers {
    ContainerisedLSF {
      actor-factory = "cromwell.backend.impl.sfs.config.ConfigBackendLifecycleActorFactory"
      config {
        concurrent-job-limit = 100
        run-in-background = true

        runtime-attributes = """
          # LSF attributes
          String  lsf_group              # Fairshare group
          String? lsf_queue  = "normal"  # Queue name
          Int?    lsf_cores  = 1         # CPU requirement
          Int?    lsf_memory = 1000      # Memory (MB) requirement

          # Containerisation attributes
          # FIXME Array[String]? is not allowed here?...
          String? docker                 # Docker image
          String? singularity            # Singularity image
          # Array[String]? mounts = []     # List of directories to mount
        """

        # TODO Directory mounting
        # FIXME The conditional mode switching is an ugly hack in Bash
        # because WDL doesn't seem to allow me to do such a thing...
        submit = """
          declare MODE
          if [[ -z "${singularity}" ]]; then
            MODE="vanilla"
          else
            MODE="singularity ${singularity}"
            MODE="$MODE --mount ${cwd} --container-working ${cwd}"
            # TODO Mounting arguments here...
          fi

          submit.sh $MODE \
                    --name "${job_name}" \
                    --group "${lsf_group}" \
                    --queue "${lsf_queue}" \
                    --cores "${lsf_cores}" \
                    --memory "${lsf_memory}" \
                    --working "${cwd}" \
                    --stdout "${out}" \
                    --stderr "${err}" \
                    -- ${script}
        """

        # TODO Directory mounting
        # FIXME? Hardcoded LSF's stdout and stderr to get around
        # Cromwell's Docker assumptions. It presumes that the CWD-based
        # path will always be correct...which it probably won't be.
        submit-docker = """
          submit.sh docker "${docker}" \
                    --name "${job_name}" \
                    --group "${lsf_group}" \
                    --queue "${lsf_queue}" \
                    --cores "${lsf_cores}" \
                    --memory "${lsf_memory}" \
                    --mount "${cwd}:${docker_cwd}" \
                    --container-working "${docker_cwd}" \
                    --working "${cwd}" \
                    --stdout "${cwd}/execution/stdout.lsf" \
                    --stderr "${cwd}/execution/stderr.lsf" \
                    -- ${script}
        """

        # FIXME These declarations only appear to apply to non-Docker
        # submissions. It's not clear how Docker job control is
        # performed; perhaps there are sister identifiers suffixed with
        # "-docker", per "submit" and "submit-docker"...
        job-id-regex = "Job <(\\d+)>.*"
        kill = "bkill ${job_id}"
        check-alive = "bjobs ${job_id}"
      }
    }
  }
}
